// transform declaration registry into typescript declarations
import { getCommentLines } from '../annotation'
import * as Declaration from './registry'

function stringifyParameters(parameters: Declaration.Parameter[]): string {
	return parameters.map(
		({name,typename}) => `${name}: ${typename}`
	).join(', ')
}

const declarationForFunction =
	(prefix: string) =>
	(func: Declaration.Function): string[] => 
{
	const {name,parameters,returnType} = func
	const parametersString: string = stringifyParameters(parameters)
	return [
		...getCommentLines(func.comment),
		`${prefix}${name}(${parametersString}): ${returnType};`
	]
}
const declarationForMemberFunction = declarationForFunction('')
const declarationForStaticFunction = declarationForFunction('static ')

function declarationForProperty(property: Declaration.Property) {
	const {name,typename} = property
	return `${name}: ${typename}`
}

function declarationForEnum(declaredEnum: Declaration.Enum): string {
	const {name, values} = declaredEnum
	const maybeExport: string = declaredEnum.shouldExport ? 'export' : ''
	return [
		`${maybeExport} interface ${name} {}`,
		`interface ${name}Enum {`,
		...values.map( value => `${value}: ${name}`).map(indent),
		'}'
	].join('\n')
}

// TS is not responsible for enforcing number sizes (int8 vs int32 etc)
function declarationForNumber(name: string) {
	return `type ${name} = number;`
}

// standalone declaration for class. used for typing
function declarationForClass(cppclass: Declaration.Class) {
	return [
		...getCommentLines(cppclass.comment),
		`export class ${cppclass.name} {`,
		...cppclass.constructors.map(declarationForConstructor(cppclass)),
		...cppclass.memberFunctions.map(declarationForMemberFunction)
			.map(indentLines).map(joinLines),
		...cppclass.staticFunctions.map(declarationForStaticFunction)
			.map(indentLines).map(joinLines),
		...cppclass.properties.map(declarationForProperty).map(indent),
		'\tdelete(): void;',
		'}'
	].join('\n')
}

const declarationForConstructor =
		(cppclass: Declaration.Class) =>
		(constructor: Declaration.Constructor): string => 
{
	const params = stringifyParameters(constructor.parameters)
	const {name} = cppclass
	return `constructor(${params}): ${name};`
}

// module declaration for class. used for access
function moduleDeclarationForClass(cppclass: Declaration.Class) {
	const {name} = cppclass
	return `${name}: typeof ${name}`
}

function moduleDeclarationForEnum(declaredEnum: Declaration.Enum) {
	const {name} = declaredEnum
	return `${name}: ${name}Enum`
}

const indent = (text: string) => `\t${text}`
const indentLines = (lines: string[]): string[] => lines.map(indent)
const joinLines = (lines: string[]): string => lines.join('\n')

function declarationForModule(
		registry: Declaration.Registry
) {
	const {moduleName} = registry;
	const lines = [
		`export interface ${moduleName} {`,
		...registry.functions.map(declarationForMemberFunction)
			.map(indentLines).map(joinLines),
		...registry.classes.map(moduleDeclarationForClass).map(indent),
		...registry.enums.map(moduleDeclarationForEnum).map(indent),
		"}",
		`declare function factory(): Promise<${moduleName}>;`,
		"export default factory;"
	]
	return lines.join('\n')
}


export function declarationsForRegistry(
		registry: Declaration.Registry
): string {
	return [
		'// generated by TSEMBIND',
		'',
		'// define type aliases for various native number types',
		...registry.numbers.map(declarationForNumber),
		'',
		...registry.enums.map(declarationForEnum),
		...registry.classes.map(declarationForClass),
		declarationForModule(registry)
	].join('\n')
}

module.exports = {declarationsForRegistry}
